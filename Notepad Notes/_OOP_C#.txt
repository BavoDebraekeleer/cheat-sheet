						  					 																			 
						  					 																			 
		 OOOOOOOOO             OOOOOOOOO        PPPPPPPPPPPPPPPPP                     CCCCCCCCCCCCC                           
	   OO:::::::::OO         OO:::::::::OO      P::::::::::::::::P                 CCC::::::::::::C      ######    ######     
	 OO:::::::::::::OO     OO:::::::::::::OO    P::::::PPPPPP:::::P              CC:::::::::::::::C      #::::#    #::::#     
	O:::::::OOO:::::::O   O:::::::OOO:::::::O   PP:::::P     P:::::P            C:::::CCCCCCCC::::C      #::::#    #::::#     
	O::::::O   O::::::O   O::::::O   O::::::O     P::::P     P:::::P           C:::::C       CCCCCC ######::::######::::######
	O:::::O     O:::::O   O:::::O     O:::::O     P::::P     P:::::P          C:::::C               #::::::::::::::::::::::::#
	O:::::O     O:::::O   O:::::O     O:::::O     P::::PPPPPP:::::P           C:::::C               ######::::######::::######
	O:::::O     O:::::O   O:::::O     O:::::O     P:::::::::::::PP            C:::::C                    #::::#    #::::#     
	O:::::O     O:::::O   O:::::O     O:::::O     P::::PPPPPPPPP              C:::::C                    #::::#    #::::#     
	O:::::O     O:::::O   O:::::O     O:::::O     P::::P                      C:::::C               ######::::######::::######
	O:::::O     O:::::O   O:::::O     O:::::O     P::::P                      C:::::C               #::::::::::::::::::::::::#
	O::::::O   O::::::O   O::::::O   O::::::O     P::::P                       C:::::C       CCCCCC ######::::######::::######
	O:::::::OOO:::::::O   O:::::::OOO:::::::O   PP::::::PP                      C:::::CCCCCCCC::::C      #::::#    #::::#     
	 OO:::::::::::::OO     OO:::::::::::::OO    P::::::::P                       CC:::::::::::::::C      #::::#    #::::#     
	   OO:::::::::OO         OO:::::::::OO      P::::::::P                         CCC::::::::::::C      ######    ######     
		 OOOOOOOOO             OOOOOOOOO        PPPPPPPPPP                            CCCCCCCCCCCCC                           
						  					 																			 
• →                                              

-- Terminologie --
------------------
• OOP = Object Oriënted Programming
	→ hiervoor Structural Programming
	
• De vier peilers van OOP:
	- Blackbox
	- Abstractie
	- Overerving
	- Polymorfisme
	
• Class/Klasse = blauwdruk die het gedrag en toestand beschrijft voor objecten,
					en bevat eigenschappen/properties en methoden.

• Object = een instantie van een klasse die werkt volgens de beschrijving van die klasse,
			en heeft een eigen toestand, gedrag en identiteit.
	→ Gedrag beschreven door de methoden van de klasse
	→ Toestand bepaald door de datamemebers beschreven in de klasse (properties en instantievariabelen)
	→ Identitiet dmv een unieke naam zodat deze kan worden aangesproken en kan interageren met andere objecten.
			
• Black-box principe: je moet niet weten wat er intern allemal gebeurt om het te gebruiken.
	→ Interface om het object te gebruiken, interne staat uitlezen en manipuleren, high level communicatie.
	→ Abstractie/encapsulate complexity, hoe eenvoudiger om te gebruiken hoe beter!

• Instantievariabelen: variabelen die de toestand van het individuele object bijhouden.
• Property: toegang geven tot instantievariabele,
	altijd public, get en set, engelse sleutel symbool
	
	Betreft het een eigenschap die een bepaalde waarde heeft, dan gebruik je een property.
	Betreft het een actie of gedrag: iets dat het object moet doen (tekst tonen, iets berekenen of aanpassen, etc.) dan plaats je het in een methode. 
	
	→ Read-only: geen setter, enkel getter
		→ met transformatie van private field data, vb. leeftijd geven adhv geboortedatum 
	→ Write-only: geen getter, wel een setter
	→ Gemengde toegang dmv: protected set { code; }
	
	→ Geen const, ref, out, meerdere variabelen, Geen code buiten de get en set.
	
	→ Auto-properties: default gedrag van getter en setter door deze niet te definiëren.
	
• Accessors: get en set bij properties.

• Singleton: klasse die slechts één object moet creëren.

• Stack: klein maar sneller geheugen.
• Heap: groot maar trager geheugen.
• GC = Garbage Collector: .NET utility die ieder object verwijderd uit de Heap waar geen referenties meer naar bestaan.
	→ gebeurt maar af en toe, niet continu.
	
• Value by reference = pointer die 64-bit geheugenadres bij houdt.
	→ alias = pointer die naar hetzelfde geheugenadres verwijst als een andere pointer, dmv = operator.
		Student a = new Student();	// nieuw object aangemaakt en geheugenadres bewaard in de pointer.
		Student b = a;				// nieuwe pointer aangemaakt die als alias dient voor a en hetzelfde geheugenadres bevat.
	
	→ Zo kan je andere objecten meegeven aan object methodes,
		of als return waarde van een methode van een object.
		
• static-keyword: de data blijft op klasse-nieveau die door alle objecten gedeeld wordt ipv dat elk object zijn eigen data heeft.

• Compositie: "heeft een"-relatie, vb. een boom heeft bladeren.
	→ ".. is entirely made of .."
	→ Alle objecten binnen het hoofdobjecten "sterven" samen met het hoofdobject.
	→ UML: volle ruit "pijl"
• Aggregatie: "lightweight" compositie. vb. een deck bevat speelkaarten
	→ ".. is part of .."
	→ Objecten binnen het hoofdobject blijven bestaan wanneer het hoofdobject "sterft".
	→ UML: lege ruit "pijl"
	
• Interface = verzameling van niet-geïmplementeerde methodes en properties:
	- geven aan WAT het gedrag is,
	- niet HOE dit moet gebeuren.
	
	→ Je kan maar overerven van één klasse, maar van meerdere interfaces.
_______________________________________________________________________________________________________________________________
-- Klasse --
------------
Blauwdruk/beschrijving voor objecten.
Beschrijft eigenschappen en gedragen.

• Aanmaken in apparte file.
	→ in VS: Project → Add class → naam geven
	
	[public] class KlasseNaam 							// = Class header/definitie
	{
		public KlasseNaam()	{ }							// = Constructor, heeft zelfde naam als de klasse
		
		private int instantieVariabelen = value;		// = Instantievariabelen, private fields of data fields (auto private, maar altijd private definiëren, private met kleine letter, public met Hoofdletter)
		
		public void Eigenschap/Property					// = (Full-)Properties, altijd public
		{ 													→ in VS: propfull + TAB + TAB
			get { return instantieVariabelen; }
			set { instantieVariabelen = value; }
			
			get => return instantieVariabelen;			// Kan ook
			set => instantieVariabelen = value;
		}
		
		public void Eigenschap/Property { get; set; }	// = Auto-properties, doet hetzelfde als standaard getter en setter zoals hierboven.
															→ in VS: prop + TAB + TAB
								{ get; private set; }		→ met private setter: propg + TAB + TAB

		public void Methode()							// Methoden altijd met Hoofdletter
		{
			//code
		}
	}
	
• Class access modifiers (optioneel): wat mag de buitenwereld zien
	- public	= iedereen kan eraan.
	- internal	= enkel zichtbaar in assembly/project van de klasse.
	- protected = object/klasse zelf kan eraan, als ook overervende klasse.
	- private	= enkel het object/klasse zelf kan eraan, overervende klasse niet! Het zit wel in de overervende klasse, maar deze kan er zelf niet aan.
	
• Constructor: speciale methode om nieuwe instantie object van een klasse te initialiseren.
	→ Naam constructor = naam klasse
		vb.:	class Pokémon {			// = Klasse naam
					public Pokémon(){	// = Constructor naam
					}
					public int HP { get; set; } = 50;
				}
	→ Er is altijd een "default Constructor" indien je deze niet schrijft in de klasse.
		Default Constructor = leeg, public (zoals vb hierboven) en onzichtbaar.
		
	→ Aanroeping bij aanmaak nieuw object, returned het object.
		vb. Pokémon pikachu = new Pokémon();
		
	→ Constructor overloading: meerdere constructors voor dezelfde klasse met andere parameters.
		→ Wanneer je herhalend dezelfde toewijzingen doet in de overloaded constructors kan je dit doen met het this-keyword:
			vb.:	class Pokémon {	
					public Pokémon(int hpIn, string naamIn){
						HP = hpIn;
						Naam = naamIn;
					}
					public Pokémon(int hpIn): this(hpIn, "GeenNaam"){	// this gaat zoeken naar de best passende constructor, hier de eerste hierboven
																		// terwijl er maar enkel hpIn is meegegeven als parameter bij het initialiseren van een object.
						// Hier kan eventueel ook nog code die wordt uitgevoerd NA de this constructor.
					}
					public Pokémon(string naamIn): this(50, naamIn){	// 50 wordt meegegeven als default waarde aan de eerste constructor
						// eventuele code								// wanneer enkel de Naam als parameter wordt opgegeven bij het initialiseren van een object.
					}
					
					private int hp;										// Instantievariabele
					public int HP { 									// Properties
						get {
							return hp;
						}
						set {
							if(value > 0)								// HP moet initieel groter als 0 zijn, anders is de Pokémon KO.
								hp = value;
							else
								hp = 20;
						}
					public int Naam { get; set; }
				}
	
	→ Constructors zijn soms nogal zwaarwichtig indien je enkel een eenvoudige autoproperty een startwaarde wenst te geven.
		Wanneer dat het geval is mag je dit ook als volgt doen:
			class Student {
				public int UurVanInschrijven {private set, get} = 2;
			}
	
• Object initializer: om specifiek de properties een waarde toe te kennen (die eventueel anders een default waarde krijgen).
	→ Aanroeping:
		KlasseNaam objectNaam = new ConstructorNaam { PropertyNaam = [value] };	// De () van de constructor mogen weggelaten worden, maar mogen er ook nog staan.
		vb. Pokémon pikachu = new Pokémon { HP = 100 };
			
			→ Doet exact hetzelfde als:
				Pokémon pikachu = new Pokémon();
				pikachu.HP = 100;
		
	→ Werkt enkel als er een default Constructor is = géén constructors geschreven, OF een lege!!
	
• .ToString() altijd implementeren in een klasse, dmv override, om de meest nuttige info te kunnen returnen, en bij debuggen te kunnen weergeven.
	(Erft virtual methode over van System.Object)
	
	vb.:	class Spaceship
			{
				public int WarpSpeed { get; set; }
				public string Naam { get; set; }
				
				public override string ToString()
				{
					return Naam + " flying at warp speed: " + WarpSpeed;
				}
				
• "this"-keyword: Dit keyword kan je aanroepen in een object om de referentie van het object terug te krijgen.
	Om instantievariabelen, properties of methodes van de klasse waarin je bezig bent, of dus zichzelf/this, aan te roepen.
	
	vb. instantievariabelen:
	
		class Monster
		{
			public Monster(int Levens)
			{								// De tweede Levens is de input van de Constructor hierboven (een betere naam is levensIn bvb),
				this.Levens = Levens;		// this.Levens wijst naar de property hieronder.
			}								// De input wordt dus toegekend aan de property binnen deze klasse.
			
			public int Levens { get; set; }
		}
	
	vb. object zelf:
	
		class Management
		{
			private const int MAXRANG = 10;
			public static bool MagPromoveren(Werknemer toCheck)
			{
				return toCheck.Rang < MAXRANG;
			}
		}
		
		class Werknemer
		{
			public int Rang { get; set; }
			public bool IsPromoveerbaar()
			{
				return Management.MagPromoveren(this);		// De klasse gebruikt de methode van de klasse Management hierboven
			}												// en geeft zichzelf mee om de check uit te voeren en het return resultaat zelf te returnen.
		}
	
_______________________________________________________________________________________________________________________________	
-- Object --
------------
Een "ding" die werkt volgens de beschrijving van de klasse.
	→ Objecten = Reference types
		→ niet hetzelfde als Valuetypes, vb. int getal;

• Aanmaken:
	KlasseNaam objectNaam;
	objectNaam = new KlasseNaam();
	
	KlasseNaam objectNaam = new KlasseNaam();
	objectNaam.Property = value;
	
_______________________________________________________________________________________________________________________________
-- Overerving --
----------------
Uitbreiding op bestaande klasse, die op zich een nieuwe klasse is.
→ "Inheritance is transitive": de SubClass krijgt alles van de SuperClass, maar uiteraard niet omgekeerd.
→ "is een"-relatie, vb.: een paard is een dier.
	→ niet hetzelfde als "heeft een"-relatie, vb.: een boek heeft een pagina → compositie!

• UML:	[ SuperClass ]←[ SubClass ]
	
• Syntax:	public class SubClassName: SuperClassName {..}

	→ Overerving voorkomen met "sealed"-keyword: sealed class SubClassName: SuperClassName {..}
	
• SubClass Constructor en "base"- en "this"-keyword:
	De constructor van een SubClass gaat altijd eerst de constructor van de SuperClass aanroepen.
	Indien je parameters moet/wenst mee te geven gebruiken we:
		public SubClassName(): base(param1, param2, .. paramN) {..}
		
		→ Indien er geen constructor bestaat in de SuperClass waar de opgegeven parameters in passen krijg je een compile-error,
			bvb ook als je "base" niet gebruikt en er geen default constructor aanwezig is in de SuperClass.
	Wens je eerst een andere constructor in de SubClass aan te roepen:
		public SubClassName(): this(param) {..}						// Gaat eerst expliciet de volgende eigen constructor aanroepen,
		public SubClassName(datatype paramName): base(param) {		// Voert deze constructor uit, waarna pas de SuperClass constructor wordt aangeroepen.
			instanceVarName = paramName;
		}
		
• Overschrijvingen van SuperClass aspecten met "virtual"- en "override"-keywords:
	- virtual:	aanduiding in de SuperClass dat overschrijving in SubClasses toe laat. (Niet mogelijk bij static methoden.)
	- override: om nieuwe aangepaste versie in een SubClass te schrijven van iets dat al bestaat in de SuperClass waar deze van overerft.
	
	- base: bij een override zeggen dat toch de originele code nog moet gebruikt worden, om dubbele code te vermijden.
	
	vb.1:	public class CustomerAccount
			{
				private decimal balance;
				
				public virtual bool WithdrawFunds(decimal amount)
				{
					if(balance < amount)
						return false;
					balance = balance - amount;
					return true;
				}
			}
			public class BabyAccount: CustomerAccount
			{
				//..
				public override bool WithdrawFunds(decimal amount)
				{
					if(10 < amount)						// We voegen toe dat er slechts max €10 kan worden afgehaald.
						return false;
					return base.WithdrawFunds(amount);	// Als het bedrag kleiner is als €10 voeren we de code uit de SuperClass uit.
				}
				
	vb.2:	class Restaurant
			{
				 protected int kosten = 0;
				 public virtual void PoetsAlles()
				 {
					   kosten += 1000;
				 }
			}
			class Frituur:Restaurant
			{
				 public override void PoetsAlles()
				 {
					   base.PoetsAlles(); 	// eerste basiskost wordt opgeteld met de code uit Restaurant
					   kosten += 500;  		// kosten eigen aan frituur worden bijgeteld
				 }							// als het bedrag in Restaurant nu gewijzigd zou worden maakt dit niet uit want er wordt altijd eerst naar daar gegaan.
			}
	
• Abstracte klasse: klasse waar geen objecten van mogen aangemaakt worden omdat het een abstract iets is, enkel "template" voor sub-klassen.
	vb.: Dier-klasse dient enkel om daaruit dieren te gaan definiëren als Sub-klassen, vb. Hond, Eend, Paard, ...
	
	→ Verplicht om bepaalde/alle delen van de SuperClass te implementeren in de SubClasses die niet definiëerbaar zijn in de SuperClass door deze ook abstract te maken.
		In de SubClasses met override implementeren.
	
		abstract class Dier
		{
			private string name;
			public Animal(string name)
			{
				this.name = name;
			}
			
			public string Name
			{
				get { return name; }
			}
			
			public abstract string Speak();		// Abstracte methode heeft geen body = {} !
		}
		
		class Hond: Dier
		{
			public Hond(string name: base(name) {}
			
			public override string Speak()
			{
				return "woof";
			}
		}


_______________________________________________________________________________________________________________________________
-- Compositie & Aggregatie --		https://apwt.gitbook.io/ziescherper/zie-scherper-semester-2/h7-compositie-en-this/0_compositie_intro
-----------------------------
• Compositie: "heeft een"-relatie, vb. een boom heeft bladeren.
	→ ".. is entirely made of .."
	→ Alle objecten binnen het hoofdobjecten "sterven" samen met het hoofdobject.
	→ UML: volle ruit "pijl"
	
• Aggregatie: "lightweight" compositie. vb. een deck bevat speelkaarten
	→ ".. is part of .."
	→ Objecten binnen het hoofdobject blijven bestaan wanneer het hoofdobject "sterft".
	→ UML: lege ruit "pijl"
	
• Manieren in de praktijk:

	1) Ogenblikkelijk:
	
		vb.:	class PC
				{
					private Disk cDisk = new Disk();
				}
				
	2) Ogenblikkelijk, maar in de constructor:
	
		vb.:	class PC
				{
					public PC()
					{
						cDisk = new Disk();			// Properder en overzichtelijker om het zoals hier in de constructor te doen.
					}
					private Disk cDisk;
				}
				
	3) Door extern object, zoals via een property:
	
		vb.:	class PC
				{
					public Disk CDisk()
					{
						get { return cDisk; }
						set { cDisk = value; }
					}
					private Disk cDisk;
				}

				myPC.CDisk = new Disk();			// Via de property een Disk-object aanmaken en toekennen aan een PC-object.
				
	vb. Combinatie van 1) en 3):
				
				class Page {}
				
				class Book
				{
					public List<Page> AllPages { get; set; } = new List<Page>();		// Auto-property
				}
				
				myBook.AllPages.Insert(new Page(), 5);	// Dit kan, maar is geen goede oplossing omdat her vereist te weten dat er intern de klasse met een List wordt gewerkt.
				
				// Betere oplossing:
				class Boek
				{
					public List<Pagina> AllePaginas {get; private set;} = new List<Pagina>();

					public void InsertPagina(Pagina paginaIn, int positie)
					{
						allPaginas.Insert(paginaIn, positie)
					}
				}

				zieScherper.InsertPagina(new Pagina(), 5);


_______________________________________________________________________________________________________________________________
-- Polymorfisme --
------------------		
• SubClass objecten kunnen bewaard worden in SuperClass pointers. Deze kunnen dan enkel de methoden en instantievariabelen aanroepen toegankelijk in de SuperClass,
	als ook de overriden versies van de SubClass, maar niet de andere specifieke methoden en instantievariabelen uit de SubClass.

	vb.:	Wagen[] autoLijst = new Wagen[3];
	
			autoLijst[0] = new Wagen();
			autoLijst[1] = new Sportwagen();
			autoLijst[2] = new Vrachtwagen();
			
			for(int=0; i<autoLijst.Length; i++)
			{
				autoLijst[i].Rapporteer();		// Rapporteer() is een methoden die in elke SubClass overriden is, maar werkt dus zoals verwacht ookal is de array v/h type v/d SuperClass.
			}
			
	vb.2:	List<Dier> zoo = new List<Dier>();
			zoo.Add(new Varken());
			zoo.Add(new Paard());
			foreach(var dier in zoo)
			{
			  Console.WriteLine(dier.MaakGeluid());
			}

• Casting van objecten naar een afgeleide kan, maar kan mislukken → exception! Zie "as"-keyword verderop.

	vb.:	Basis obj = new Afgeleide();
			Afgeleide obj2 = (Afgeleide) obj;

• "is"-keyword: controleren of variabele van bepaald type is, of overerft van bepaald type.
	→ returned bool
	
	vb.:	class Vehicle {..}
			class Car: Vehicle {..}
			class Person {..}
			
			Car myCar = new Car();
	
			if(myCar is Vehicle) {..} 		// Returned true
			if(myCar is Car) {..}			// Returned true
			if(myCar is Person) {..}		// Returned false

• "as"-keyword: casting naar andere klasse, maar indien dit niet lukt returned null ipv een exception.

	vb.:	Student fritz = new Student();
			Mens jos = fritz as Mens();			// Mens en Student erven niet van elkaar over, dus jos krijgt waarde null.
			if(jos!=null) {..}					// Controleren of de casting gelukt is door null-check te doen.
_______________________________________________________________________________________________________________________________
-- System.Object --
-------------------		
• Alle klassen in C# erven over van de root klasse System.Object.
	Als je van niets overerft staat er eigenlijk: public class ClassName: System.Object {..}
	
• de virtual methoden kan je overschrijven:
	- Equals()		Vergelijkt objecten en kijkt of ze gelijk zijn.
	- GetHashCode()	Geeft unieke code voor een object, om sorting en data management te doen.
	- GetType()		Returned het type/klasse van een object.
	- ToString()	Returned eenn string die het object representeert. Als niet gedefinieerd roept deze GetType() aan.
					→ Als je zelf een klasse maakt altijd ToString() methode overriden om de meest nuttige info hiermee te returnen.
					
	→ vb. override van Equals():
	
		class Point
		{
			...
			
			public override bool Equals (object obj)
			{
				if(obj != null)										// 1. Controleren of het object bestaat.
				{
					if(obj is Point)								// 2. Controleren of het object v/d klasse Point is.
					{
						Point temp = (Point) obj;					// 3. Met obj heb je geen toegang tot de private instantievariabelen.
																	//		Door middel van casting kunnen we echter een tijdelijke kopie maken
						if(this.X == temp.X && this.Y == temp.Y)	//		om vervolgens de vergelijking van instantievariabelen te kunnen doen
							return true;							//		op dit object (this) waarop de methode wordt aangeroepen, 
					}												//		en het te vergelijken object (meegegeven als obj → temp).
				}
				else return false;
			}
		}
		
	vb.2:
	
		//In de Student class
		public override bool Equals(Object o)
		{  
			Student temp = o as Student; 
			if(temp != null)
			{ 
				return (Geboortejaar == temp.Geboortejaar && Voornaam == temp.Voornaam);
			}
			return false;
		}
		
	OF
	
	//In de Student class
	public override bool Equals(Object o)
	{  
		if(o is Student)
		{ 
			Student temp = o as Student; 
			return (Geboortejaar == temp.Geboortejaar && Voornaam == temp.Voornaam);
		}
		return false;
	}

_______________________________________________________________________________________________________________________________
-- DateTime --
--------------
• Huidige tijd en datum:
	DateTime currentTime = DateTime.Now;
	
• Zelf kiezen:
	DateTime birthday = new DateTime(1991, 07, 23);
	DateTime moment = new DateTime(2017, 1, 18, 10, 16, 34);
	
• Ingebouwde methoden die nieuw DateTime object returnen:
	- AddDays
	- AddHours
	- AddMilliseconds
	- AddMinutes
	- AddMonths
	- AddSeconds
	- AddTicks
	- AddYears
	
	DateTime timeNow = DateTime.Now;
	DateTime nextWeek = timeNow.AddDays(7); 	→ wijzigt timeNow NIET! Creëert nieuw object.
	
• Ingebouwde properties: toegang tot interne staat van een DateTime object, returned value
	- Date
	- Day, DayOfWeek, DayOfYear
	- Hour, Millisecond, Minute, Month, Second, Ticks
	- TimeOfDay
	- Today
	- UtcNow
	- Year

	DateTime moment = DateTime.Now;
	int year = moment.Year;
	
• Formateren:
	WriteLine(moment.ToString("[letter]"));
		→ letter:	d = short date
					D = long date
					F = full date and time
					M = month and day
					o = date and time separated
					R = RFC1123 date and time
					t = short time
					T = long time
					Y = year and month

• Static methoden, aangeroepen op de klasse, niet objecten:
	- Parsing: zet string om in een DateTime object
		string date_string = "8/11/2013";
		DateTime dt = DateTime.Parse(date_string);
	
	- IsLeapYear: geeft bool terug of het jaar een schrikkeljaar is of niet.
		DateTime today = DateTime.Now;
		bool isLeap = DateTime.IsLeapYear(today.Year);
		
• TimeSpan:
	Verschil tussen twee DateTime objecten of optellen.
	
	DateTime vandaag = DateTime.Today;
	DateTime geboorteDochter = new DateTime(2009, 6, 17);
	TimeSpan verschil = vandaag - geboorteDochter;
		
_______________________________________________________________________________________________________________________________
-- Stack vs Heap --
-------------------		
• (Data) Stack: klein maar sneller geheugen.
	Specifiek voor elk programma.
	
	- Value types: de eigenlijke data.
		→ variabelen zoals int, float, string, boolean, enum, structs, ...
		→ datatypes waar de grote van gekend is.
	- Beginwaardes: 0, 0.0, "", false, ...
	- = operator kopiëert de actuele waarde.
	- LIFO-stapel: last in, first out
	- Geheugen binnen huidige scope, buiten scope wordt verwijderd.

• Heap (global memory): groot maar trager geheugen.
	RAM, swap file, geheugen beschikbaar voor lopende programma's dat de geheugen controller van het OS managed.
	
	- Reference types: een referentie naar de eigenlijke data.
		→ datatypes waarvan de grote niet gekend is, vb. arrays, objecten
		→ werking code vb.:
			
			public class Account { public string Name; }
			
			static void Main(string[] args) {
				Account TimsAccount;					// reference/pointer met waarde null wortd aangemaakt in de stack, nog geen geheugenadres (64-bit)
				TimsAccount = new Account();			// in de Heap wordt een Account object aangemaakt, met variabele Name.
			}											// Nu kennen we de geheugen lengte en het geheugenadres wordt in de pointer bewaard.
		
	- Beginwaarde: null
	- = operator kopiëert het adres naar de actuele waarde.
	
• GC = Garbage Collector: .NET utility die ieder object verwijderd uit de Heap waar geen referenties meer naar bestaan.
	→ gebeurt maar af en toe, niet continu.

• Value by reference = pointer die 64-bit geheugenadres bij houdt.
	→ alias = pointer die naar hetzelfde geheugenadres verwijst als een andere pointer, dmv = operator.
		Student a = new Student();	// nieuw object aangemaakt en geheugenadres bewaard in de pointer.
		Student b = a;				// nieuwe pointer aangemaakt die als alias dient voor a en hetzelfde geheugenadres bevat.
	
	→ Zo kan je andere objecten meegeven aan object methodes,
		of als return waarde van een methode van een object (zoals de constructor ook doet).
		
_______________________________________________________________________________________________________________________________
-- Exception handeling --
-------------------------
• Exception = er is een uitzondering opgetreden tijdens het uitvoeren van het programma.
• Exception handeling = afhandelen van de uitzonderinge op een gecontroleerde manier tijdens uitvoer.

• Keywords:
	- throw
	- try
	- catch
	- finally
	
	→ try-catch vb.:
		try {
			// probeer deze code waar mogelijks exceptions optreden
		}
		catch([exceptionKlasseNaam e]) {	// "e" is naam die je aan de exception geeft, kan ook "ex" zijn of eender wat
			// als try-block niet lukt, geef info door, vb aan gebruiker "verkeerde invoer",
			of verwerkt de genoemde exception om het programma verder te doen gaan, of "graceful shutdown"
			hoe specifieker, hoe meer vanboven (SystemException is specifieker als Exception, zie soorten)
		}
		finally {
			// voer deze code ook nog uit, vb. bestand sluiten dat geopend is.
		}
		
		vb code:
		catch (Exception e)
		{
			Console.WriteLine("Exception opgetreden");
			Console.WriteLine("Message:"+e.Message);

			Console.WriteLine("Targetsite:" + e.TargetSite);
			Console.WriteLine("StackTrace:" + e.StackTrace);
		}
		
	→ throw vb.:	throw new DevideByZeroException("Jouw fout boodschap komt hier.");
		
• Exception-object: bevat info over de fout
	- Properties:
		• Message: kort bericht
		• StackTrace: hierarchie van mlethodes die geleid hebben tot de exception
		• Source
		• TargetSite
		• InnerException
	- Methode:
		• ToString()

• Exception: (erven over van elkaar → Exception is een klasse van het .NET framework)
	- SystemException: Klasse voor uitzonderingen die niet al te belangrijk zijn en die mogelijk verholpen kunnen worden.
		• NullReferenceException: nog geen object geïnstantieerd met new-operator, pointer bevat null!!
		• ArithmeticException:
			- StackOverflowException: oneindige loop die het Stack geheugen volledig opvult en er buiten gaat treden.
				Bvb schrijffout in methoden, hoffdletter ipv kleine letter, 
				waardoor de methode steeds opnieuw wordt aangeroepen tot het Stack geheugen vol zit en gestopt wordt door deze error.
			- DivideByZeroException
		• IndexOutOfRangeException: De index is te groot of te klein voor de benadering van een array
		• FormatException
		• IOException:
			- FileNotFoundException
			- EndOfStringException
	- ApplicationException
	
	https://docs.microsoft.com/en-us/dotnet/api/?view=net-5.0
	
• Zelf exceptions maken door klasse te definieren die overerft van Exception (of één van de SubClasses van Exception).
	
	class NewExceptionName: Exception
	{
		//code
	}
_______________________________________________________________________________________________________________________________
-- Namespaces en "using" --
---------------------------
Om aan te duiden in welke code/bibliotheken de compiler moet zoeken naar de code van wat je wilt doen,
maar ook conflicten vermijden door vb. klassen met dezelfde naam uit verschillende projecten of libraries die je beiden wilt gebruiken.
	namespace = gemeente/postcode voor een adres die in meerdere gemeenten voorkomt vb. Kerkstraat 1

Code:	using System;								// laat je toe vb. Console.WriteLine(); te schrijven ipv System.Console.WriteLine();
													// de System library zit ingebakken in .NET, System is hier de namespace.
		namespace ProgrammaNaam {					// Namespace is hetzelfde, maar eigen code, vb. in een andere file.
			class Program {
				static void Main(string[] args) {
					// code
				}
			}
		}
		
	→ Generate type: als je een klasse wilt gebruiken dat nog niet bestaat kan je deze typen en dan met "Generate type" auto genereren in apart bestand.	
		
_______________________________________________________________________________________________________________________________
-- static-keyword --
--------------------
De data blijft op klasse-niveau die door alle objecten gedeeld wordt ipv dat elk object zijn eigen data heeft.
Wordt ook bij libraries gebruikt vb. Math-class van .NET library is static → aanroepen: double result = Math.Pow(4,2);

vb.:	class Pokémon {								// als je "static class Pokémon" schrijft = "static class", kan je geen objecten maken, maar is de klasse een uniek object!
			static private int aantalPokémon = 0;	// "static field" gedeeld op klasse niveau
			
			public Pokémon(string name){			// Constructor, kan je ook static maken, deze wordt dan enkel uitgevoerd bij het initialiseren van het eerste object.
				interneNaam = name;
				aantalPokémon++;					// iedere keer de constructor wordt aangeroepen en dus een nieuwe Pokémon wordt ontworpen aantalPokémon+1 
			}										// en dient deze dus als teller om bij te houden hoeveel Pokémon objecten er bestaan.
			
			public int HP { get; set; } = 50;		// "static property" gedeeld op klasse niveau
			}
			
			public void ToonNaam() {
				Console.WriteLine(interneNaam);
			}
			
			static public void ToonAantalPokémon() {
				Console.WriteLine(aantalPokémon);
			}
		}
		
• Aanroepbaar op de klasse, NIET op objecten!
	vb.:	Pokémon pikachu = new Pokémon("Pikachu");
			pikachu.ToonNaam();							// non-static methode wordt op object aangeroepen
			Pokémon.ToonAantalPokémon();				// static methode wordt op de klasse aangeroepen!
			
• Zo kan je ook een klasse maken met allerlei static hulpmethodes in, en properties, een eigen library eigenlijk, die je dan in meerdere projecten kan gebruiken,
	en waar je dan, om ze te kunnen gebruiken, niet telkens een object voor moet aanmaken, maar gewoon kan aanroepen op de klasseNaam.
	→ zie video OOP H3.4
	→ let op namespaces!
	
• Random in klassen static maken zodat er maar één Random-object bestaat voor elke instantie.
	vb.:	class Dobbelsteen
			{
				static Random gen = new Random();
				public int Werp()
				{
					return gen.Next(1,7);
				}
			}
	
_______________________________________________________________________________________________________________________________
-- Debug.WriteLine --	https://apwt.gitbook.io/ziescherper/zie-scherper-semester-2/h3-gevorderde-klasseconcepten/5_static
---------------------
De Debug klasse (die in de System.Diagnostics namespace staat) kan je gebruiken om eenvoudig zaken naar het debug output venster te sturen tijdens het debuggen. 

vb.:
		using System;
		using System.Diagnostics;

		namespace debugdemo
		{
			class Program
			{
				static void Main(string[] args)
				{
					Console.WriteLine("Hello World! Console");
					Debug.WriteLine("Hello World! Debug");		// Komt in het Output venster in VS!
				}
			}
		}
		
_______________________________________________________________________________________________________________________________
-- Arrays van objecten --
-------------------------
→ Array van reference values/pointers, dus mogelijk "null".

• Standaard syntax vb.:
	Pokémon mijnDeck = new Pokémon[10];			// Returned enkel een nieuwe array waar 10 Pokémon objecten in passen. De references zijn nu nog allemal "null".

	mijnDeck[0] = new Pokémon();				// Pokémon-object aanmaken en reference in de array bewaren.

	for(int i = 0; i < mijnDeck.Length; i++)	// Met loop array opvullen.
	{
		mijnDeck[i] = new Pokémon();
	}
	
	mijnDeck[0].Naam = "Pikachu";				// Properties aanspreken met .Dot-notatie
	
• Array initializer syntax vb.:
	Pokémon pikachu = new Pokémon();			// Pokémon object pikachu aanmaken
	
	Pokémon[] mijnDeck = new Pokémon[]			// Pokémon-object array met plaats voor de volgende 3 Pokémon objecten.
	{
		pikachu,								// Je kan bestaande object references toevoegen,
		new Pokémon(),							// zowel als ineens nieuwe objecten aanmeken om toe te voegen, gescheiden door een "," .
		new Pokémon()
	};											// Afgesloten met een ";" !

• Null-check "?"
	mijnDeck?[0]?.Naam = "Pikachu";				// Eerste "?" controleerd of de array zelf niet "null" is, de tweede of er een reference value is op die index.

• Object arrays als parameters en return, vb.:

	static Student[] CreateEmptyStudentArray()
	{
		return new Student[10]();
	}

	Student[] resultaat = CreateEmptyStudentArray();
	
	
_______________________________________________________________________________________________________________________________
-- List<>-collectie --
----------------------
Vergelijkbaar met een array, maar als een generieke klasse met methoden.
	→ Generieke klassen oftewel "generic classes" zijn een handig concept om je klassen nog multifunctioneler te maken doordat we zullen toelaten dat bepaalde datatypes niet hardcoded in onze klasse moet gezet worden.
		List<> is zo'n eerste voorbeeld, maar er zijn er tal van anderen én je kan ook zelf dergelijke klassen schrijven.

	→ using System.Collections.Generic
	
	→ List is "dynamisch": als je middenin een element verwijdert schijven de achterliggende elementen een index op, terwijl bij een array zou de index gewoon leeg zijn.

• Syntax:	List<datatype> listNaam = new List<datatype>();
	→ Je hoeft geen begingrootte mee te geven, ze groeien mee.
	
	vb.1: List<int> alleGetallen = new List<int>();
	vb.2: List<string[]> listOfStringarrays = new List<string[]>();
	
• Object initialiser syntax, vb.:
	List<Pokemon> pokedex = new List<Pokemon>()
    {
        new Pokemon(),
        new Pokemon()
    };
	
	→ Object initialiser syntax binnen deze, vb.:
	List<Pokemon> pokedex = new List<Pokemon>()
    {
        new Pokemon() {Naam = "Pikachu", HP_Base = 5},
        new Pokemon() {Naam = "Bulbasaur", HP_Base = 15}
    };
	
• Methoden:
	- listNaam.Add([wat je wilt toevoegen]);
		vb.:	List<Pokemon> pokedex = new List<Pokemon>();
				pokedex.Add(new Pokemon());
				
	- listNaam.Clear(): methode die de volledige lijst leegmaakt en de lengte (Count) terug op 0 zet.
	- listNaam.Insert(): methode om een element op een specifieke plaats in lijst in te voegen.
	- listNaam.IndexOf(): geeft de index terug van het element item in de rij. Indien deze niet in de lijst aanwezig is dan wordt -1 teruggegeven.
	- listNaam.RemoveAt(): verwijdert een element op de index die je als parameter meegeeft.

• .Count ipv .Length, vb.:
	for(int i = 0 ; i < mijnPersonages.Count; i++)
	{
		Console.WriteLine(mijnPersonages[i])
	}
	
	→ Of met foreach-loop, vb.:
		List<int> getallen = new List<int>();
		getallen.Add(5);
		getallen.Add(7);
		foreach(var getal in getallen)
		{
			Console.WriteLine(getal);
		}
		
_______________________________________________________________________________________________________________________________
-- Foreach loop --		https://apwt.gitbook.io/ziescherper/zie-scherper-semester-2/h4-arrays-en-klassen/3_foreach
------------------
Een foreach loop zal ieder element in de array één voor één in een tijdelijke variabele plaatsen (de iteration variable),
zodat binnenin de loop met dit ene element kan gewerkt worden.
Het voordeel hierbij is dat je geen teller/index nodig hebt en dat loop zelf de lengte van de array zal bepalen.

	→ Read-only! Je kan met een foreach-loop geen waarden aanpassen omdat de "iteration variable" een reference bevat, niet de waarde zelf.
		Je kan wel een methode van een object aanroepen die de waarde verandert.
	→ Gebruik enkel wanneer je de volledige array/list wilt aflopen.
	→ In VS: foreach + TAB + TAB

• Syntax:	foreach (datatype/var itemNaam in array/ListNaam)	→ bij gebruik van var ziet de compiler aan de array/list welk datatype gebruikt moet worden.
			{
				// Doe iets met itemNaam
			}

	vb.:
		double[] killDeathRates = {1.2, 0.89, 3.15, 0.1};

		foreach (double singleKD in killDeathRates)
		{
		   Console.WriteLine($"Kill/Death ratio is {singleKD}");
		}
		
• var-keyword:
	Bij JavaScript heeft var een totaal andere functie, daar zegt het eigenlijk: "het type dat je in deze variabele kan steken is...variabel". 
	Met andere woorden het kan de ene keer een string zijn, dan een int. Bij C# gaat dit niet: 
	eens je een variabele aanmaakt dan zal dat type onveranderbaar zijn en kan je er alleen waarden aan toekennen van dat type. 
	JavaScript is namelijk een dynamically typed language terwijl C# een statically typed language is (er is één uitzondering bij C# hieromtrent: 
	wanneer je met dynamic leert werken kan je C# ook tijdelijk als een dynamically typed taal gebruiken).
	
	→ Gebruik var wanneer het duidelijk is wat je wilt opvangen in de variabelen en/of dubbele code vermijden,
		vb. bij objecten: var pikachu = new Pokémon(); ipv: Pokémon pikachu = new Pokémon();
	
_______________________________________________________________________________________________________________________________
-- Dictionary --		https://apwt.gitbook.io/ziescherper/zie-scherper-semester-2/h4-arrays-en-klassen/dict
----------------		= generieke 'collectie-klasse'
• Ieder element bestaat uit:
	- Key: unieke waarde of id, ipv een index bij arrays/lists
	- Value: waarde van het element
	
• Syntax:	Dictionary<datatypeKey, datatypeValue> dictionaryName = new Dictionary<datatypeKey, datatypeValue>();
	vb.: 	Dictionary<int, string> klanten = new Dictionary<int, string>();

• Methoden:
	- dictionaryName.Add(key, value);	→ Element toevoegen						vb.: 	klanten.Add(123, "Tim Dams");
	- dictionaryName.Remove(key);		→ Element verwijderen adhv de key		vb.: 	studentenLijst.Remove("AB12");
	- dictionaryName.ContainsKey(key);	→ Controleren of key al bestaat, bool	vb.:	if(!studentenlijst.ContainsKey("AB12") {..}
	- dictionaryName[key]				→ value uitlezen adhv de key			vb.:	Console.WriteLine(klanten[123]);
	- foreachItem.Key					→ key uitlezen in een foreach-loop
	- foreachItem.Value					→ value uitlezen in een foreach-loop	vb.: 	foreach (var item in klanten)
																						{
																							Console.WriteLine(item.Key+ "\t:"+item.Value);
																						}
																						
code vb.:
	Dictionary<string, Student> studentenLijst = new Dictionary<string, Student>();
	Student stud = new Student() { Naam = "Tim", Geboortejaar = 2001 };
	studentenLijst.Add("AB12", stud);
	Console.WriteLine(studentenLijst["AB12"].Geboortejaar);
	studentenLijst.Remove("AB12");
	
	
_______________________________________________________________________________________________________________________________
-- Interfaces --	Programmatische concepten, NIETS te maken met UI!
----------------
• Interface = verzameling van niet-geïmplementeerde methodes en properties:
	- geven aan WAT het gedrag is,
	- niet HOE dit moet gebeuren.
	
	"Interfaces are just promises."
	
• Syntax:	interface interfaceName		// Startend met "I" om leesbaarder te zijn als interface, vb. IAccount, IAdvisor, ... 
			{
				returntype methodName(..);
				...
				returntype propertyName { get; set; };
				...
			}

	→ Geen access modifiers (public, private, ...) → altijd auto public
	→ Geen body
	→ Geen fields/members, enkel methodes en properties
	→ Je kan nieuwe types (bv enum) in een interface declareren.
	
	→ Interfaces kunnen overerven van andere interfaces, maar uiteraard niet van klasse.
		Zelfde syntax als bij klassen, maar waar bij klasse er maar kan overgeërfd worden van 1 klasse, kunne er meerdere interfaces gebruikt worden.
		
		vb. gebruik:	class DarthVader: StarWarsCharacter, IForceUser, IPilot		// Eerst de klasse, dan de interfaces!
		
	→ Ook abstracte klassen kunnen één of meerdere interfaces hebben. In het geval van een abstracte klasse is deze niet verplicht de interface ook al te implementeren, 
		en mag (delen van) de interface ook als abstract aangeduid worden.
		
	→ Dankzij interface kunnen we als het ware een stukje de beperking dat je maar van 1 klasse kunt overerven opvangen. 
		Sommige klassen ZIJN een voertuig MAAR OOK een Superheld. Met andere woorden, klassen kunnen meerdere interfaces implementeren.
		Merk wel op dat de interface NIET de implementatie bevat van wat een superheld juist doet. 
		Het gaat enkel beloven dat de klasse bepaalde methoden en properties heeft.
		
	
	vb.:	public interface IAccount
			{
				void PayInFunds(decimal amount);
				bool WithdrawFunds(decimal amount);
				decimal GetBalance();
				int Balance { get; set; }
			}
			
			public class Account {..}
			
			public class CustomerAccount: Account, IAccount		// Erft over van Account, en gebruikt IAccount als Interface (kunnen meerdere interfaces zijn gescheiden door komma).
			{
				private decimal balance;
				
				public CustomerAccount() {..}
			
				public void PayInFunds(decimal amount);			// De methodes uit de IAccount interface moeten allemaal worden geïmplementeerd.
				{
					balance = balance + amount
				}
				public bool WithdrawFunds(decimal amount);
				{
					if(balance < amount)
						return false;
					balance = balance - amount;
					return true;
				}
				public decimal GetBalance();
				{
					return balance;
				}
				public int Balance			// Zelf toegevoegd, kan fout zijn!
				{
					get
					{
						return this.balance;
					}
					private set
					{
						this.balance = value
					}
				}
			}

• Polymorfisme:	je kan objecten toewijzen aan variabelen van een interfacetype.
	Het object zal dan enkel die zaken "kunnen" die de interface beschrijft.

→ Je kan maar overerven van één klasse, maar van meerdere interfaces.

• Er zijn al heel wat ingebouwde interfaces in .NET voor bestaande zaken die je eventueel kan implementeren in je klassen wens je ze te gebruiken.
	→ Meer gebruikte bestaande interfaces:
		- IEnumerable: for use with foreach and LINQ.
		- IDisposable: for resources requiring cleanup, used with using.
		- IQueryable: lets you execute requests against queriable data sources.
		- INotifyPropertyChange: for data binding to UI classes in WPF, winforms and Silverlight
		- IList and ICollection: for mutable collections.
		- IDictionary: for lookup collections.
		- IEquatable and IEquialityComparer: for generalized equality.
		- IComparable and IComparer: for generalized sorting.

			vb. CompareTo implementatie:
	
				class Country: IComparable
				{
					private string name;
					private int landArea;
					private int inhabitants;
					
					public Country(string n, int l, int i) {..}
					
					...
					
					#region IComparable Members
					
					public int CompareTo(object obj)
					{
						if(obj is Country)
						{
							Country temp = obj as Country();
							if(temp != null)
							{
								if(this.landArea > temp.landArea)		// This instance is GREATER than obj to compare.	→ +1
									return 1;
								else if(this.landArea < temp.landArea)	// This instance is LESS than obj to compare.		→ -1
									return -1;
								else									// This instance is greater EQUAL obj to compare.	→ 0
									return 0;
							}
						}
					}
				}
				
	→ "is"- en "as"-keywords werken ook met interfaces.
	
	
In kleine projecten lijken interfaces wat overkill, en dat zijn ze vaak wel. 
Van zodra je een iets complexer project krijgt met meerdere klassen die onderling met elkaar allerlei zaken moeten doen, 
dan zijn interfaces je dikke vrienden! Je hebt misschien al over de SOLID programmeerprincipes gehoord?
Samengevat zegt SOLID dat we een bepaalde hoeveelheid abstractie inbouwen enerzijds 
(zodat we niet de gore details van klassen moeten kennen om er mee te programmeren) 
anderzijds dat er een zogenaamde 'separation of concerns' (SoC) moet zijn (ieder deel/klasse/module van je code heeft een specifieke opdracht).
Met interfaces kunnen we volgens de SOLID principes programmeren: het boeit ons niet meer wat er in de klasse zit, 
we kunnen gewoon aan de interfaces van een klasse zien wat hij kan doen. Handig toch!